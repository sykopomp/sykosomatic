* Tasks
** Pages
*** /newchar
**** TODO Configuration UI
     Set up a nice web interface that waifu can use to do basic CRUD on all the different character
     creation options.
**** TODO Create appropriate entities and modifiers
**** TODO (Maybe) Previews
    Each section should have an informative preview that shows how the player's selections are
    affecting something about the character. Refer to waifu's handy-dandy notes for specifics.
***** TODO Identity
     Have a sentence that is auto-updated as they pick things from the dropdown and type in a name.
     Something like "You are creating a new character. His name is Thomas Janus, also known as
     'Wolf'."
***** TODO Early Life
     A sentence that gives a basic blurb about the character's family and childhood information,
     which also includes the identity:
     "Thomas grew up in a middle class family of three children by his two parents."
***** TODO Later Life
     "Now Thomas is a <age determined by career> year old. He has some acquaintances, but no one
     really very close. He is also currently seeing someone. He has spent 10 years in Business."
***** TODO Here and Now
     For this one, show an interactive map of the Twin Cities. Perhaps start with a short snippet
     about what the Twin Cities are, and maybe even some outside links to more information. There
     should be various places marked on the map, each corresponding to a possible starting location
     for the character. Maybe have these places marked by Google Maps-style drops/pins.  Clicking
     on a location or choosing it from the dropdown makes it the current selection, and also
     displays a short paragraph with more information about what the place is like -- something to
     give the player an idea of why it sets it apart from the other locations.
***** TODO Confirm
     Summarize all the other stuff that was accumulated during character creation, and have the
     player confirm their decision. The actual submit button will be in here.

**** TODO Proper inputs
    Replace the mass of text input fields with appropriate stuff like dropdowns.
***** TODO Careers
****** TODO Use jQuery UI 1.9's spinner widget for number input
       meh. Maybe wait for 1.9 to get released.
***** TODO Location
****** TODO Draw up a map of the area
****** TODO Highlight places in the map according to selection
****** TODO Expand description of place according to selection
***** TODO Headings
      I think headings are supposed to be helpful for folks using screen readers and the like. Look
      into this, and add them where appropriat
**** TODO Disable 'add' buttons when appropriate
*** /my-account
    Need to have this page to manage account information.
**** TODO Allow changing of display name.
**** TODO Allow changing passwords.
**** TODO More involved user bio?
*** /recover-password
**** TODO Set up an email-based password recovery system
*** /view-scene
**** TODO Scene editing
     I like the idea of rendering each 'sentence'/unit as a targetable DOM element (such as SPANs
     for sentences in a paragraph), and using jQuery UI to make those units individually
     draggable. I don't think I want to allow full editing of scenes (might feel like it defeats the
     purpose of -playing- the scenes if you can just -write- them), but this might be a really neat
     feature that allows cleaning up garbage without giving too much freedom (or requiring too much
     effort to handle formatting, and the like).
** Websocket client
*** TODO Fancy JS 'parser'
     See sketch on whiteboard.

     Basically, the parser is less text-based and more text-guided. An interactive completion system
     will ensure that all items are uniquely chosen before the final message is even sent.  This
     will probably involve caching of at least part of the game's vocabulary client-side, but we'll
     take that step when it's necessary.

**** DONE Disable completion system for now
     Having a halfassed completion system and updating it while figuring out what the optimal use
     case is will only cause problems.
**** DONE Extend parser to support objects
     Target grammar: [adverb ws] verb [ws object] [ws adverb]
**** DONE command-definition system
     Have a system for defining commands, which can then be associated with verbs. These commands
     must accept and handle all parts of the sentence. One command could be shared by any number of
     verbs -- for example: 'smiles', 'laughs', 'grins' can all be associated with a single command
     (let's call it base-social for argument's sake).
***** DONE Figure out what commands need
      actor, verb, adverbs, direct-object, indirect-object, do-preposition, io-preposition.
      I believe anything that commands need to do their work can be extracted from these components
      of the sentence, such as the actor's location, name, etc etc.
***** DONE Command CRUD
      The usual. Commands are lisp code, so they should just live in an in-memory hash table or
      something, keyed by name.
***** DONE Command-definition macro
      defcommand or whatever. Make it convenient to define/redefine these things.
***** DONE Associate with vocabulary verbs
      Add a system of doing CRUD on verb->command associations. These live in the database.
**** DONE Command execution
***** DONE Figure out how parse-action (and parser.lisp in general) should relate to websocket.lisp
      It seems like parser.lisp is full of stuff that should just be commands in websocket.lisp (and
      the commands in -that- file should probably be moved out.
***** DONE Write a sample command
      A simple emote command that takes care of basic social verbs. Don't worry about handling all
      the variables from parsing.
***** DONE Hook command up to game
      So it actually gets used.
***** DONE Write utility functions for from-command output queueing
      Commands themselves should be the ones sending messages out to object/players. At the same
      time, they're supposed to be blind to websockets. Therefore, there needs to be a way to either
      directly send, or enqueue message sends to *entities*, which, at the websocket.lisp level,
      takes care of sending messages out to connected clients that control those entities.
      
      I like the idea of having a (memory-stored) queue of messages that a thread goes through. This
      will need to support sending all the various client messages, like dialogue, transitions, etc,
      in case commands want to handle them.
**** TODO Extend parser to support full grammar
     sentence = [adverb ws] verb [ws noun-clause] [ws noun-clause] [ws adverb]

     Where noun-clause is a clause representing one or more objects visible to the associated
     actor. It may be a prepositional phrase, in which case that preposition is kept. More detailed
     grammar notes (and initial parsers) are spread around parser.lisp.

     The full parser should return enough objects to bind all of the command variables, which
     includes up to 4 adverbs, a set of direct objects, a set of indirect objects, and prepositions
     associated with the direct and indirect objects.
**** TODO The Test
     Target parsed sentence: 'kindly smiles with X at Y and Z.'
     Target output: 'John Doe kindly smiles with X at Y and Z.'

     Where X, Y, and Z are *toplevel* entities. They could be the same object.

     Output should go to all connected clients.
**** TODO FUTURE Command overrides
     Instead of putting command associations into verbs, make a command-association table that maps
     verbs to command names. This table should also include columns for most (if not all) of the
     action parameters. These can then be used to create 'multimethods' of sorts: By querying for
     specific parameters, default commands can be shadowed. For example, one could write a 'method'
     where a certain combination of actor/direct-object will yield a specific result. In general,
     this should not be used, but it may become handy when very-special-code is needed.
**** TODO Add completion features to dialogue input area
**** TODO (maybe) Improve error reporting
     For what it's worth... this may be a waste of time, if all input has to be fully 'completed'
     once we have the full game frontend. If that's the case, we can just ignore erroneous input
     because it means the player has bypassed the standard client.
***** TODO Do something about that ENOPARSE garbage
***** TODO When an adverb is wrong and a verb is write, report it as such
      If someone enters 'merrly jumps', it should properly report the error as 'merrly is not an
      adverb', instead of 'merrly is not a verb'.
**** TODO (maybe) In the completion popup, group matches by verb and by adverb
     Kinda like an <optgroup>. jquery-ui's autocomplete supports this.
     NOTE: Maybe in the future. Whole-sentence is easier for now. :\
*** DONE Use character/named library
*** DONE Clean up websocket.lisp
    It's a bloody mess in there
**** DONE Only the session and the actor-id need to be kept
**** DONE Instead of using web session, make web clients identify with a single-use token
**** DONE Get rid of resource-client-connected
     Validation no longer needs to be split up into two steps. Have resource-received-text do a
     quick check to see if the session is already being tracked, and if it's valid. If it's not,
     treat it as the validation step, etc.
**** DONE Reorganize the file so it's more readable
*** TODO Semantic markup for game area
    This should probably include changes to the command output functions such that they're not
    simple string concatenations. Actual objects/ids should be passed around, which a command
    rendering engine will then take care of converting into tagged text.
    Perhaps all that is needed is an sexp/xml tagging system that will 'mark up' zones of the output
    text semantically.

    Examples:
      - '(:e 12345 John Doe) (:verb jumps) to (:e 4322 Jane).'
      - '<e id='12345'>John Doe</e> <verb>jumps</verb> to <e id="4322">Jane</e>.'

    Probably just do the former for now, since it's nicer to deal with, and handle the xml version
    later.
*** TODO (re)design client
    The UI is currently all sorts of awful. The currently-necessary components should be gathered,
    and decent designs should be agreed upon for all of it. Waifu recommends brainstorming sessions
    followed by user testing. Not sure how much user testing we can do, but even a little bit
    helps. Maybe pick something not-too-awful and then start doing honest user testing once we have
    a few early testers?
*** TODO Give client.js a once-over.
    Probably worth revisiting the way things are being 'exported' and the like. Some of the stuff in
    that file might be useful in other pages, as well. Perhaps it should actually be used as a
    shared library of sorts. Maybe also rename it to sykosomatic.js?
*** TODO If the current entity's name changes in the database, tell the client
    A nice message through the websocket to update the client's display.
*** TODO Scene headers
**** TODO Add a scene-header server->client message
     Should include the url for an image to load and the name of the location.
**** TODO Get client to render the scene header.
*** TODO Make sure a user is chatting as a character only once.
*** TODO Back-button-friendliness
     When you leave the chat page, the websocket is disconnected. If you press 'back', though, the
     input fields are enabled, as if the websocket connection were still up. Perhaps there's a
     javascripty way to reconnect the websocket on back-button?
     Maybe this could be achieved with disabled=true by default for chat inputs?
*** TODO No Flash on native-websocket browsers
     Things got messed up when I tried to have optional loading of Flash. Give it another shot.
*** TODO Sticky scene headers
     Ideally, scene headers will 'stick' to the top of the screen when the entire screen belongs to
     a particular scene -- always leaving clue of where the player currently is.  As new scene
     headers appear, they should scroll up regularly, and 'bump' off the older sceneheader as they
     reach the top of the screen, sticking there until the next header rolls by.
*** TODO Character conversion
     Convert -- to —.
*** TODO Do something about the awful OOC area.
*** TODO Scene recording
**** TODO Select area to record
**** TODO Scene naming
     Add ability to change the name of the recorded session.
     NOTE: Perhaps more important than this -- descriptions? I'll do this later.
*** TODO FUTURE WAI-ARIA support
     The web client should play nice with screen readers.
*** TODO FUTURE define a language-agnostic command definition protocol (a-la-couchdb)
*** TODO FUTURE Client customization by users
** Misc Webapp work
*** TODO Sessions
**** TODO Concurrent session/session history information
     Since sessions last a long time, have a screen where a user can log out all other active
     sessions.
**** TODO Log out all sessions on username or password change
**** DONE Make sure session-verify really is thread-safe.
*** TODO Email system
    Need a way to send emails out to people. Various things in the site will need this.
*** TODO Form builder
    Need a form builder that supports validation, error reporting, rendering, and CSRF tokens. This
    can be an independent library. freiksenet says he'll do it.
*** TODO Logging system
    Need to add a robust way to log server errors/notices/warnings in a more sysadmin-friendly way.
*** TODO Use 'real' templates
    Enough of yaclml. Maybe using yaclml is okay for a limited subset of generated components, but
    most templates should be in their own files, organized by webpage names. Give tal a shot for
    this. Whatever ends up being used, it may need to be extended in order to support the form builder.
*** TODO Put locks on session value and finalizer hash tables
*** TODO Figure out how to put the server behind stud
    URL: https://github.com/bumptech/stud
*** TODO Figure out how to configure two lisp processes running behind HAProxy
*** TODO Use a couple of lisps with single-threaded-taskmaster instances
** Game
*** DONE Clarify relationship between account characters, actors, and entities
    Entity: a game object, which a client may be using as its "Body"
    Body: a game object a client is directly controlling. AKA its entity-id.
    Actor: For the sake of dialogue/actions, the entity who is understood to be performing the action.
*** DONE Implement body/actor/entity clarification
**** DONE Make websocket.lisp use plain old entity IDs for the current actor.
**** DONE Think about how to represent entity<->connected-client relationship
**** DONE Update websocket.lisp to use nameable instead of character to render names and find things.
**** DONE Make character.lisp create a nameable instead of slapping modifiers on an entity.
**** DONE update character.lisp to only handle character creation.
**** DONE rename character module to character-creation.
*** TODO Fix timer
    It's not quite working right now, although there's a reasonable rate limit. that might be okay
    for now.
*** TODO Cleaner es-thread shutdown
    Don't just murder the thread when we want to murder it. Get it to shut down cleanly.
*** TODO Add concept of a 'location'
    Once characters exist, we can start adding the concept of a 'location' to the game. Locations
    should have a description, and should be able to 'contain' other characters. Characters can only
    interact with other characters provided they are in the same location.
*** TODO Put characters in a location
*** TODO Limit dialogue/action interactions to same location
*** TODO Location transitions
    Changing locations should have a couple of effects:
**** TODO Scene transition.
     The actor who is moving from point A to point B should receive a short scene-transition
     message, which should be properly formatted as a transition.
**** TODO Slug lines and descriptions
     Upon entering the new area, the actor who moved should receive both a new slug line (displayed
     after the transition message), followed by the new location's description.
**** TODO Hi, I'm here!
     Once the actor has transitioned into the new location, everyone, including the actor, should
     receive a "X arrives." message. This'll eventually be extended to provide fancier, nicer
     transitions, but an arrival message is good enough for now.
*** TODO Location building.
    Write an interface that can be used to easily build and connect locations.
*** TODO Persistent scenes
    NOTE: This'll need to be done *after* characters are implemented.
    Players should be able to 'record' scenes, which will be saved as they see them. These scenes
    should be viewable in a separate page (for phase 1). Would be nice to also have them formatted
    as screenplays.
    Not all user messages must (or should) be saved. Instead, create a 'recorded session' document,
    and then record each line of input that the character is witness to into 'entry' documents,
    which can then be collated with the recorded session as outlined in the CouchDB Joins article.
**** TODO Revive persistent scenes
     Haven't been tested since pomo switch
**** TODO Automatically add slug lines.
     Even if the user starts recording a while after entering an area, the recorded scene should
     include the slug line for that area. Will probably have to wait until we have locations. :)
**** TODO Automatically add location description under slug line.
     May need to wait until locations are implemented (although no harm in having some default text
     for now). Under the slug line for persisted scenes, the description of the location, as seen by
     the character at that point in time, should be included at the top of the scene.
**** TODO Scene collection
     Users should be able to 'collect' others' stories, much like in DA.
**** TODO FUTURE "Canon" system.
    While people can tell any story they want, how about giving extra weight to stories that fit the
    game's canon, and/or are staff approved?
** Game Building
*** TODO Component manager
    Parts of the game should be split into components (things like nameable, describable,
    weight/size, combat stats, contents, all being components).
    Components can be arbitrarily added/removed through a web interface, and each component should
    have a custom data editor for configuration.
    Components can be represented by block areas in a single entity editor screen. Or something like
    that. Should also have entity searching features.
    Sounds like a generic component registration system is needed that includes a particular API,
    built forms, etc.
*** TODO Vocabulary manager
    A manager for doing CRUD on vocabulary words, configuring what commands verbs are attached to
    (and possibly viewing the source code for the commands, or at least the documentation for them).
*** TODO Room builder
    A dedicated entity editor meant for linking together various rooms, with a nicer view than just
    using the raw component manager. You should be able to do all that this screen can do with the
    component manager, though.
** Database
*** TODO Remove s-sql patch
    Waiting until the new pomo makes it into a quicklisp release.
*** DONE 'init db' system of some sort
    Needs to both create all tables, insert any initial data stored elsewhere, and remind admin to
    execute whatever external command needs to be executed post-boot (such as installing unaccent).
**** DONE init hooks for individual modules
**** DONE Figure out a way to remind/enforce unaccent's existence
     A plain old init hook that queries for the extension's existence is enough. :)
*** TODO Look into offering my pooling improvements to postmodern
    Postmodern already has a pooled connection system. Look at it a little closer and figure out how
    it might benefit from my own pooling system (and/or if it's worth using instead of my own
    pooling system).
*** DONE Fix package issues with type names in defdao
*** TODO Figure out a cleaner way of 'passing through' s-sql stuff
*** TODO Nameable must-refresh-full-name constraint?
    Is it possible to put in a constraint that prevents updates of nameable if a new full-name is
    not provided? Most likely, I'll need to write a trigger that does this.
** Security
*** TODO HTTPS
    May not need/want hunchentoot managing this. Check out http://haproxy.1wt.eu/, which supposedly
    supports both https and wss.
*** TODO XSS
    There should be a specific method of handling all user input, and all redisplaying of
    server-side data such that XSS is not possible. This should be handled within the
    infrastructure.
**** TODO De-XSS-ify server-side generated HTML.
     This involves using yaclml's <:ah
*** TODO CSRF
    Nothing to defend against this right now. Most likely, the form builder should have something
    built-in that manages and checks tokens.
*** TODO Injection
    This is mostly taken care of by using s-sql. Keep an eye out, though. Looks like (:raw) is
    mostly protected as well, thanks to the whole (wrapping) thing. :D
*** TODO DoS
**** TODO Throttle user input.
     Length and regularity of user input should be somewhat limited, so players can't just spam a
     ton of garbage onto the screen.

*** TODO Malicious websocket clients
    The websocket client should not leak anything the player would not already be able to do through
    the interface. Object identities should be hidden somehow.
    
*** DONE sykosomatic.account:gensalt uses cl:random
     Might be a good idea to put the openssl-based random numgen in util.lisp or something.
** Misc
*** DONE Start writing unit tests
*** TODO Write a macro to simplify one-package-per-file
**** DONE Merge defpackage and in-package
**** DONE Have it always :use :cl, :alexandria, and :sykosomatic.util
**** TODO Ability to disable defaults
**** TODO Is it possible to extract the package name from the -filename-?
*** DONE Write a macro to simplify one-test-per-module
    On top of the one-package-per-file thing, it should also define the relevant suite
*** TODO Move persistent sessions out into a separate lisp project
*** TODO Move timer.lisp into an external project
*** TODO Merge smug.lisp changes into mainline smug and use that version instead
*** TODO Actual config file system for local configs
* Right now
** TODO Complete enough command output stuff to C-c C-t The Test
